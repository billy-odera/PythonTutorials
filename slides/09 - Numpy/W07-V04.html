<!DOCTYPE html>
<html>
<head>
  <title>NumPy</title>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="generator" content="pandoc" />




  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">

  <base target="_blank">

  <script type="text/javascript">
    var SLIDE_CONFIG = {
      // Slide settings
      settings: {
                title: 'NumPy',
                        useBuilds: true,
        usePrettify: true,
        enableSlideAreas: true,
        enableTouch: true,
                        favIcon: 'W07-V04_files/logo.png',
              },

      // Author information
      presenters: [
            {
        name:  'Dr. Felipe Campelo<br/>Aston University' ,
        company: '',
        gplus: '',
        twitter: '',
        www: '',
        github: ''
      },
            ]
    };
  </script>

  <link href="W07-V04_files/ioslides-13.5.1/fonts/fonts.css" rel="stylesheet" />
  <link href="W07-V04_files/ioslides-13.5.1/theme/css/default.css" rel="stylesheet" />
  <link href="W07-V04_files/ioslides-13.5.1/theme/css/phone.css" rel="stylesheet" />
  <script src="W07-V04_files/ioslides-13.5.1/js/modernizr.custom.45394.js"></script>
  <script src="W07-V04_files/ioslides-13.5.1/js/prettify/prettify.js"></script>
  <script src="W07-V04_files/ioslides-13.5.1/js/prettify/lang-r.js"></script>
  <script src="W07-V04_files/ioslides-13.5.1/js/prettify/lang-yaml.js"></script>
  <script src="W07-V04_files/ioslides-13.5.1/js/hammer.js"></script>
  <script src="W07-V04_files/ioslides-13.5.1/js/slide-controller.js"></script>
  <script src="W07-V04_files/ioslides-13.5.1/js/slide-deck.js"></script>

  <style type="text/css">

    b, strong {
      font-weight: bold;
    }

    em {
      font-style: italic;
    }

    summary {
      display: list-item;
    }

    slides > slide {
      -webkit-transition: all 0.4s ease-in-out;
      -moz-transition: all 0.4s ease-in-out;
      -o-transition: all 0.4s ease-in-out;
      transition: all 0.4s ease-in-out;
    }

    .auto-fadein {
      -webkit-transition: opacity 0.6s ease-in;
      -webkit-transition-delay: 0.4s;
      -moz-transition: opacity 0.6s ease-in 0.4s;
      -o-transition: opacity 0.6s ease-in 0.4s;
      transition: opacity 0.6s ease-in 0.4s;
      opacity: 0;
    }
/* https://github.com/ropensci/plotly/pull/524#issuecomment-468142578 */
slide:not(.current) .plotly.html-widget{
  display: block;
}

    slides > slide:not(.nobackground):before {
      font-size: 12pt;
      content: "";
      position: absolute;
      bottom: 20px;
      left: 60px;
      background: url(W07-V04_files/logo.png) no-repeat 0 50%;
      -webkit-background-size: 30px 30px;
      -moz-background-size: 30px 30px;
      -o-background-size: 30px 30px;
      background-size: 30px 30px;
      padding-left: 40px;
      height: 30px;
      line-height: 1.9;
    }
  </style>

  <link rel="stylesheet" href="shiny-slides.css" type="text/css" />

</head>

<body style="opacity: 0">

<slides>

  <slide class="title-slide segue nobackground">
        <aside class="gdbar"><img src="W07-V04_files/logo.png"></aside>
        <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
    <hgroup class="auto-fadein">
      <h1 data-config-title><!-- populated from slide_config.json --></h1>
      <h2 data-config-subtitle><!-- populated from slide_config.json --></h2>
      <p data-config-presenter><!-- populated from slide_config.json --></p>
          </hgroup>
  </slide>

<slide class=""><hgroup><h2>Overview</h2></hgroup><article  id="overview">

<ul>
<li>The <strong>NumPy</strong> module</li>
<li>NumPy arrays, concatenation and splitting</li>
<li>Computation on NumPy arrays <br><br></li>
<li>Acknowledgments</li>
<li>This slide deck was heavily inspired on ake VanderPlas&#39; <em>Python Data Science Handbook</em>, <a href='https://jakevdp.github.io/PythonDataScienceHandbook/02.00-introduction-to-numpy.html' title=''>Chapter 2</a></li>
<li>The unit was developed with the invaluable help of <a href='https://github.com/joealcantara/' title=''>Mr. Jomar Alcantara</a> from Aston University, UK.</li>
</ul>

</article></slide><slide class=""><hgroup><h2>Introducing NumPy</h2></hgroup><article  id="introducing-numpy">

<ul>
<li>NumPy is the fundamental package for scientific computing in Python.</li>
<li>It provides a particularly versatile data type called a <em>multidimensional array</em> (also called an N-dimensional array, <code>ndarray</code>), as well as various derived objects (such as masked arrays and matrices)</li>
<li>Numpy also provides an assortment of routines for fast operations on arrays, including mathematical and logical operations, shape manipulation, sorting, selecting, I/O, mathematical transforms (such as, e.g., Fourier transforms), basic linear algebra, basic statistical operations, random simulation, and much more.</li>
</ul>

</article></slide><slide class=""><hgroup><h2>Introducing NumPy</h2></hgroup><article  id="introducing-numpy-1">

<ul>
<li>At the core of the NumPy package is the <code>ndarray</code> object, which encapsulates n-dimensional arrays of homogeneous data types</li>
<li>Many operations on <code>ndarray</code> objects are performed in compiled code (for performance).</li>
<li>NumPy arrays have a fixed size at creation, unlike Python lists (which can grow dynamically). Changing the size of an <code>ndarray</code> creates a new array and deletes the original.</li>
<li>Elements in a NumPy can only be of a single, homogeneous data type (and thus will be the same size in memory).

<ul>
<li>Exception: it is possible to have arrays of (Python, including NumPy) objects, thereby allowing for arrays of different sized elements.</li>
</ul></li>
</ul>

</article></slide><slide class=""><hgroup><h2>Introducing NumPy</h2></hgroup><article  id="introducing-numpy-2">

<ul>
<li>NumPy arrays facilitate advanced mathematical and other types of operations on large numbers of data. Typically, such operations are executed more efficiently and with less code than is possible using Python&#39;s built-in sequences.</li>
<li>A growing plethora of scientific and mathematical Python-based packages are using NumPy arrays; though these typically support Python-sequence input, they convert such input to NumPy arrays prior to processing, and they often output NumPy arrays.</li>
<li>In other words, in order to efficiently use much (perhaps even most) of today’s scientific/mathematical Python-based software, just knowing how to use Python’s built-in sequence types is insufficient - one also needs to know how to use NumPy arrays.</li>
</ul>

</article></slide><slide class=""><hgroup><h2>Vectorisation and Broadcasting</h2></hgroup><article  id="vectorisation-and-broadcasting">

<ul>
<li>Two of NumPy&#39;s features which are the basis of much of its power are vectorization and broadcasting.</li>
<li>Vectorization describes the absence of any explicit looping, indexing, etc., in the code - these things are taking place, of course, just &quot;behind the scenes&quot; in optimized, pre-compiled C code.</li>
<li>Broadcasting is the term used to describe the implicit element-by-element behavior of operations.</li>
</ul>

</article></slide><slide class=""><hgroup><h2>Vectorisation</h2></hgroup><article  id="vectorisation">

<ul>
<li>Vectorized code has many advantages, among which are:</li>
<li>vectorized code is more concise and easier to read</li>
<li>fewer lines of code generally means fewer bugs</li>
<li>the code more closely resembles standard mathematical notation (making it easier, typically, to correctly code mathematical constructs)</li>
<li>vectorization results in more &quot;Pythonic&quot; code. Without vectorization, our code would be littered with inefficient and difficult to read <code>for</code> loops.</li>
</ul>

</article></slide><slide class=""><hgroup><h2>Broadcast</h2></hgroup><article  id="broadcast">

<ul>
<li>Generally speaking, in NumPy all operations - not just arithmetic, but also logical, bit-wise, functional, etc. - behave in an element-by-element fashion (which is called <em>broadcasting</em>).</li>
<li><code>a</code> and <code>b</code> could be multidimensional arrays of the same shape, or a scalar and an array, or even two arrays of with different shapes, provided that the smaller array is “expandable” to the shape of the larger in such a way that the resulting broadcast is unambiguous.</li>
<li>For the detailed rules of broadcasting, see <a href='https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html' title=''>https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html</a>.</li>
</ul>

</article></slide><slide class=""><hgroup><h2>NumPy and object orientation</h2></hgroup><article  id="numpy-and-object-orientation">

<ul>
<li>NumPy fully supports an object-oriented approach, starting, once again, with <code>ndarray</code>.</li>
<li><code>ndarray</code> is itself a class, possessing numerous methods and attributes. Many of its methods mirror functions in the outermost NumPy namespace, giving the programmer complete freedom to code in whichever paradigm she prefers, and/or which seems most appropriate to the task at hand.</li>
</ul>

</article></slide><slide class=""><hgroup><h2>NumPy arrays</h2></hgroup><article  id="numpy-arrays">

<ul>
<li>If we have a Python list, we can easily greate a NumPy object from it using:</li>
</ul>

<pre class = 'prettyprint lang-python'>import numpy as np # use np as an alias
some_numbers = [1, 2, 2, 3, 3, 3]
my_array = np.array(some_numbers)
my_array
#&gt; array([1, 2, 2, 3, 3, 3])</pre>

</article></slide><slide class=""><hgroup><h2><code>ndarray</code> attributes</h2></hgroup><article  id="ndarray-attributes">

<ul>
<li>To explore the useful array attributes provided by the <code>ndarray</code> class, let&#39;s start by defining three random arrays with one, two, and three dimensions</li>
<li>We&#39;ll use NumPy&#39;s random number generator.</li>
</ul>

<pre class = 'prettyprint lang-python'>np.random.seed(42)  # set seed of the PRNG

x1 = np.random.randint(10, size=6)         # 1D array
x2 = np.random.randint(10, size=(3, 4))    # 2D array
x3 = np.random.randint(10, size=(3, 4, 5)) # 3D array

x2 # print x2
#&gt; array([[2, 6, 7, 4],
#&gt;        [3, 7, 7, 2],
#&gt;        [5, 4, 1, 7]])</pre>

</article></slide><slide class=""><hgroup><h2><code>ndarray</code> attributes</h2></hgroup><article  id="ndarray-attributes-1">

<ul>
<li>Each array has attributes <code>ndim</code> (number of dimensions), <code>shape</code> (size of each dimension), and <code>size</code> (the total number of elements in the array, i.e., the product of all elements in <code>shape</code>)</li>
<li>Another useful attribute is the <code>dtype</code>, which informs the data type of the elements in the array</li>
</ul>

<pre class = 'prettyprint lang-python'>x3.ndim
#&gt; 3
x3.shape
#&gt; (3, 4, 5)
x3.size
#&gt; 60
x3.dtype
#&gt; dtype(&#39;int64&#39;)</pre>

</article></slide><slide class=""><hgroup><h2>Array indexing</h2></hgroup><article  id="array-indexing">

<ul>
<li>Indexing in NumPy is very similar to indexing in Python lists. In a one-dimensional array, the <em>i</em>-th value (remember that the count starts from <em>zero</em>) can be accessed by specifying the desired index in square brackets, just as with Python lists:</li>
</ul>

<pre class = 'prettyprint lang-python'>x1
#&gt; array([6, 3, 7, 4, 6, 9])
x1[0]  # first item
#&gt; 6
x1[-2] # second-to-last item
#&gt; 6</pre>

</article></slide><slide class=""><hgroup><h2>Array indexing</h2></hgroup><article  id="array-indexing-1">

<ul>
<li>In multidimensional arrays, items can be accessed using comma-separated indices:</li>
</ul>

<pre class = 'prettyprint lang-python'>x2
#&gt; array([[2, 6, 7, 4],
#&gt;        [3, 7, 7, 2],
#&gt;        [5, 4, 1, 7]])
x2[2, 0] # third row, first column
#&gt; 5
x2[1, 1] = 9 # to modify a single element
x2
#&gt; array([[2, 6, 7, 4],
#&gt;        [3, 9, 7, 2],
#&gt;        [5, 4, 1, 7]])</pre>

</article></slide><slide class=""><hgroup><h2>Array slicing</h2></hgroup><article  id="array-slicing">

<ul>
<li>Square brackets can also be used to access sub-arrays with the <em>slice</em> notation, marked by the colon (:) character. The NumPy slicing syntax follows that of the standard Python list.</li>
</ul>

<pre class = 'prettyprint lang-python'>x = np.arange(12)
x
#&gt; array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
x[:5]    # first five elements
#&gt; array([0, 1, 2, 3, 4])
x[10:]   # all elements after index 10
#&gt; array([10, 11])
x[4:7]   # a range of values
#&gt; array([4, 5, 6])
x[::3]   # every third element
#&gt; array([0, 3, 6, 9])
x[1::2]  # every other element, starting at index 1
#&gt; array([ 1,  3,  5,  7,  9, 11])</pre>

</article></slide><slide class=""><hgroup><h2>Array slicing</h2></hgroup><article  id="array-slicing-1">

<ul>
<li>If the step value is negative, the defaults for start and stop are swapped.</li>
<li>This is a convenient way to reverse an array:</li>
</ul>

<pre class = 'prettyprint lang-python'>x[::-1]  # all elements, reversed
#&gt; array([11, 10,  9,  8,  7,  6,  5,  4,  3,  2,  1,  0])
x[5::-2]  # reversed every other from index 5
#&gt; array([5, 3, 1])</pre>

</article></slide><slide class=""><hgroup><h2>Array slicing</h2></hgroup><article  id="array-slicing-2">

<ul>
<li>Multi-dimensional slices work in the same way, and can have multiple slices.</li>
</ul>

<pre class = 'prettyprint lang-python'>x2
#&gt; array([[2, 6, 7, 4],
#&gt;        [3, 9, 7, 2],
#&gt;        [5, 4, 1, 7]])
x2[:2, :3] # first 2 rows of the first 3 columns
#&gt; array([[2, 6, 7],
#&gt;        [3, 9, 7]])
x2[1, ::2]  # first row, every other column
#&gt; array([3, 7])</pre>

</article></slide><slide class=""><hgroup><h2>Array slicing</h2></hgroup><article  id="array-slicing-3">

<ul>
<li>To extract whole rows or columns, simply <code>:</code>.</li>
</ul>

<pre class = 'prettyprint lang-python'>x2
#&gt; array([[2, 6, 7, 4],
#&gt;        [3, 9, 7, 2],
#&gt;        [5, 4, 1, 7]])
x2[:, 1] # all rows, second column
#&gt; array([6, 9, 4])
x2[0, :] # first row, all columns
#&gt; array([2, 6, 7, 4])</pre>

<pre class = 'prettyprint lang-python'># In the case of row access, the empty slice can be omitted
x2[0] # same as x2[0, :]
#&gt; array([2, 6, 7, 4])</pre>

</article></slide><slide class=""><hgroup><h2>Slice subarrays are not copies!</h2></hgroup><article  id="slice-subarrays-are-not-copies">

<ul>
<li>A very important thing about <code>ndarray</code> slices is that they return views rather than copies of the array data.</li>
</ul>

<pre class = 'prettyprint lang-python'>x2
#&gt; array([[2, 6, 7, 4],
#&gt;        [3, 9, 7, 2],
#&gt;        [5, 4, 1, 7]])
x2_sub = x2[:, 2] # extract the third column
x2_sub[0] = -1    
x2
#&gt; array([[ 2,  6, -1,  4],
#&gt;        [ 3,  9,  7,  2],
#&gt;        [ 5,  4,  1,  7]])</pre>

<ul>
<li>This can be useful: when working with large datasets, we can access and process pieces of these datasets without the need to copy the underlying data buffer.</li>
</ul>

</article></slide><slide class=""><hgroup><h2>Reshaping arrays</h2></hgroup><article  id="reshaping-arrays">

<ul>
<li>Reshaping an array is essentialy reformatting it with a different dimension sizes. This can be most easily performed using the <code>reshape</code> method:</li>
</ul>

<pre class = 'prettyprint lang-python'>x = np.arange(1, 10) # integers from 1 to 9, inclusive
x.reshape((3, 3)) # notice that the argument is a tuple
#&gt; array([[1, 2, 3],
#&gt;        [4, 5, 6],
#&gt;        [7, 8, 9]])</pre>

<ul>
<li>Note that the <code>size</code> of the initial array must match that of the reshaped array.</li>
</ul>

</article></slide><slide class=""><hgroup><h2>Reshaping arrays</h2></hgroup><article  id="reshaping-arrays-1">

<ul>
<li>Another common reshaping pattern is the conversion of a one-dimensional array into a two-dimensional row (or column) matrix.</li>
<li>In addition to the <code>reshape</code> method, this can also be easily done using the <code>newaxis</code> keyword within a slice operation:</li>
</ul>

<pre class = 'prettyprint lang-python'>x = np.array([1, 2, 3])
x[np.newaxis, :]
#&gt; array([[1, 2, 3]])
x[:, np.newaxis]
#&gt; array([[1],
#&gt;        [2],
#&gt;        [3]])</pre>

</article></slide><slide class=""><hgroup><h2>Concatenation and splitting</h2></hgroup><article  id="concatenation-and-splitting">

<ul>
<li>Concatenation of two arrays in NumPy is done using <code>np.concatenate</code>, <code>np.vstack</code>, and <code>np.hstack</code>.</li>
</ul>

<pre class = 'prettyprint lang-python'>x = np.array([1, 2, 3])
y = np.array([3, 2, 1])
z = np.array([2, 1, 3])
np.concatenate([x, y, z]) # takes a list/tuple of arrays as argument
#&gt; array([1, 2, 3, 3, 2, 1, 2, 1, 3])</pre>

</article></slide><slide class=""><hgroup><h2>Concatenation and splitting</h2></hgroup><article  id="concatenation-and-splitting-1">

<ul>
<li><code>np.concatenate</code> also work on 2D (or 3D) arrays</li>
</ul>

<pre class = 'prettyprint lang-python'>grid = np.array([[1, 2, 3],
                 [4, 5, 6]])
np.concatenate([grid, grid]) 
#&gt; array([[1, 2, 3],
#&gt;        [4, 5, 6],
#&gt;        [1, 2, 3],
#&gt;        [4, 5, 6]])</pre>

<pre class = 'prettyprint lang-python'># Do it along the second axis
np.concatenate([grid, grid], axis = 1) 
#&gt; array([[1, 2, 3, 1, 2, 3],
#&gt;        [4, 5, 6, 4, 5, 6]])</pre>

</article></slide><slide class=""><hgroup><h2>Concatenation and splitting</h2></hgroup><article  id="concatenation-and-splitting-2">

<ul>
<li>For working with arrays of mixed dimensions, it can be clearer to use <code>np.vstack</code> (vertical), <code>np.hstack</code> (horizontal) instead.</li>
<li><code>np.dstack</code> (depth stacking, for 3D arrays) is also available.</li>
</ul>

<pre class = 'prettyprint lang-python'>x = np.array([1, 2, 3])
np.vstack([grid, x])
#&gt; array([[1, 2, 3],
#&gt;        [4, 5, 6],
#&gt;        [1, 2, 3]])</pre>

<pre class = 'prettyprint lang-python'>y = np.array([[99], [98]])
np.hstack([grid, y])
#&gt; array([[ 1,  2,  3, 99],
#&gt;        [ 4,  5,  6, 98]])</pre>

</article></slide><slide class=""><hgroup><h2>Concatenation and splitting</h2></hgroup><article  id="concatenation-and-splitting-3">

<ul>
<li>The opposite of concatenation is splitting, which can be done using <code>np.split</code>, <code>np.hsplit</code>, and <code>np.vsplit</code>. For each of these, we can pass a list of indices giving the split points.</li>
</ul>

<pre class = 'prettyprint lang-python'>x = np.arange(10)
x1, x2, x3, x4, x5 = np.split(x, [2, 4, 6, 8])
print(x1, x2, x3)
#&gt; (array([0, 1]), array([2, 3]), array([4, 5]))
print(x4, x5)
#&gt; (array([6, 7]), array([8, 9]))</pre>

</article></slide><slide class=""><hgroup><h2>Concatenation and splitting</h2></hgroup><article  id="concatenation-and-splitting-4">

<pre class = 'prettyprint lang-python'>grid = np.arange(24).reshape((6, 4))
grid
#&gt; array([[ 0,  1,  2,  3],
#&gt;        [ 4,  5,  6,  7],
#&gt;        [ 8,  9, 10, 11],
#&gt;        [12, 13, 14, 15],
#&gt;        [16, 17, 18, 19],
#&gt;        [20, 21, 22, 23]])
g1, g2 = np.vsplit(grid, [3])
g3, g4 = np.hsplit(grid, [2])
print(g1)
#&gt; [[ 0  1  2  3]
#&gt;  [ 4  5  6  7]
#&gt;  [ 8  9 10 11]]
print(g3)
#&gt; [[ 0  1]
#&gt;  [ 4  5]
#&gt;  [ 8  9]
#&gt;  [12 13]
#&gt;  [16 17]
#&gt;  [20 21]]</pre>

</article></slide><slide class=""><hgroup><h2>Computation on NumPy arrays</h2></hgroup><article  id="computation-on-numpy-arrays">

<ul>
<li>One of the most interesting features of NumPy is the availability of vectorized operations, which replace slow loops by what is called <em>universal functions</em>, or <strong>ufuncs</strong>.</li>
<li>Just like in R, loops tend to be relatively (read: very) slow in Python. This is mainly because of Python&#39;s need to do type-checking (and a few associated tasks) every time the function is called.</li>
<li>In contrast, when working with compiled code (such as in C or Java) the type is always known beforehand, making the computations more efficient.</li>
</ul>

</article></slide><slide class=""><hgroup><h2>Computation on NumPy arrays</h2></hgroup><article  id="computation-on-numpy-arrays-1">

<ul>
<li>For many types of operations, NumPy provides a convenient interface to <em>vectorize</em> operations so that they can be performed behind-the-scenes using compiled code methods.</li>
<li>This vectorized approach is designed to push loops into the compiled layer that underlies NumPy, leading to much faster execution.</li>
<li>In most cases this is done so transparently that the user does not even notice.</li>
</ul>

</article></slide><slide class=""><hgroup><h2>Computation on NumPy arrays</h2></hgroup><article  id="computation-on-numpy-arrays-2">

<ul>
<li>For instance, suppose you wish to compute the square value of all elements a long numeric array. You can either do an elementwise <code>for</code>-loop, or simply:</li>
</ul>

<pre class = 'prettyprint lang-python'>import numpy
long_array = np.random.randint(1, 32, size = 100000)
squared_vals = long_array ** 2
long_array[0:5]
#&gt; array([29, 15, 13,  1, 25])
squared_vals[0:5]
#&gt; array([841, 225, 169,   1, 625])</pre>

<ul>
<li>This can also be done for higher-dimensional arrays.</li>
</ul>

</article></slide><slide class=""><hgroup><h2>Computation on NumPy arrays</h2></hgroup><article  id="computation-on-numpy-arrays-3">

<ul>
<li>All common arithmetic operations (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>**</code>, <code>//</code>, <code>%</code>) are implemented as <em>ufuncs</em> for NumPy. When combined, they (of course) maintain the standard order of operations.</li>
<li>Other functions available as <em>ufuncs</em> include:</li>
<li>Triginometric: <code>np.sin</code>/<code>arcsin</code>, <code>np.cos</code>/<code>arccos</code>, <code>np.tan</code>/<code>arctan</code></li>
<li>Exponentials (a<sup>x</sup>): <code>np.exp</code>, <code>np.exp2</code>, , <code>np.power</code></li>
<li>Logarithms: <code>np.ln</code>, <code>np.log2</code>, <code>np.log10</code></li>
<li>&#8230;</li>
</ul>

</article></slide><slide class=""><hgroup><h2>Computation on NumPy arrays</h2></hgroup><article  id="computation-on-numpy-arrays-4">

<ul>
<li>NumPy has many more <em>ufuncs</em> available, including hyperbolic trigonometrics, bitwise arithmetic, comparison operators, angle conversion, rounding, etc.</li>
<li>NumPy has a submodule, <code>scipy.special</code>, that features a number of these more specialised functions, including gamma and beta functions, error functions, and many others.</li>
</ul>

</article></slide><slide class=""><hgroup><h2>Computation on NumPy arrays</h2></hgroup><article  id="computation-on-numpy-arrays-5">

<ul>
<li>For binary <em>ufuncs</em>, some interesting aggregates can be computed directly from the object.</li>
<li>For example, if we want to <em>reduce</em> an array with a particular operation, it is possible to use the <code>reduce</code> method of <strong>any</strong> <em>ufunc</em>. A <em>reduce</em> repeatedly applies a given operation to the elements of an array until only a single result remains.</li>
<li>For example, calling <code>reduce</code> on the add <em>ufunc</em> returns the sum of all elements in the array:</li>
</ul>

<pre class = 'prettyprint lang-python'>x = np.arange(1, 11) # [1, 2, ..., 10]
np.add.reduce(x)
#&gt; 55</pre>

</article></slide><slide class=""><hgroup><h2>Computation on NumPy arrays</h2></hgroup><article  id="computation-on-numpy-arrays-6">

<ul>
<li>Similarly, <code>reduce</code> can be similarly called on any other <em>ufunc</em>, e.g., on the <code>multiply</code> function (to return a product of all array elements), using <code>np.multiply.reduce</code></li>
<li>If the intermediate results are of interest, we can use <code>accumulate</code> instead of <code>reduce</code>.</li>
</ul>

<pre class = 'prettyprint lang-python'>x = np.arange(1, 6) # [1, 2, ..., 5]
print(np.multiply.reduce(x))
#&gt; 120
print(np.multiply.accumulate(x))
#&gt; [  1   2   6  24 120]</pre>

</article></slide><slide class=""><hgroup><h2>Computation on NumPy arrays</h2></hgroup><article  id="computation-on-numpy-arrays-7">

<ul>
<li>Finally, any <em>ufunc</em> can also compute the output of all pairs of two different inputs using the <code>outer</code> method. For instance, to create a multiplication table you only need:</li>
</ul>

<pre class = 'prettyprint lang-python'>x = np.arange(1, 11)
np.multiply.outer(x, x)
#&gt; array([[  1,   2,   3,   4,   5,   6,   7,   8,   9,  10],
#&gt;        [  2,   4,   6,   8,  10,  12,  14,  16,  18,  20],
#&gt;        [  3,   6,   9,  12,  15,  18,  21,  24,  27,  30],
#&gt;        [  4,   8,  12,  16,  20,  24,  28,  32,  36,  40],
#&gt;        [  5,  10,  15,  20,  25,  30,  35,  40,  45,  50],
#&gt;        [  6,  12,  18,  24,  30,  36,  42,  48,  54,  60],
#&gt;        [  7,  14,  21,  28,  35,  42,  49,  56,  63,  70],
#&gt;        [  8,  16,  24,  32,  40,  48,  56,  64,  72,  80],
#&gt;        [  9,  18,  27,  36,  45,  54,  63,  72,  81,  90],
#&gt;        [ 10,  20,  30,  40,  50,  60,  70,  80,  90, 100]])</pre>

</article></slide><slide class=""><hgroup><h2>Summary</h2></hgroup><article  id="summary">

<ul>
<li>NumPy provides a very versatily data type, <code>ndarray</code>, which powers many of the top Python packages for data science.</li>
<li><em>ufuncs</em> vectorise the execution of element-wise functions on NumPy arrays, increasing efficiency</li>
<li>We have only scratched the surface. If you want to lear more (you should!), check the <a href='https://docs.scipy.org/doc/' title=''>NumPy documentation</a>, or the full <a href='https://jakevdp.github.io/PythonDataScienceHandbook/02.00-introduction-to-numpy.html' title=''>Chapter 2 of the Python Data Science Handbook</a>.</li>
</ul></article></slide>


  <slide class="backdrop"></slide>

</slides>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

<!-- map slide visiblity events into shiny -->
<script>
  (function() {
    if (window.jQuery) {
       window.jQuery(document).on('slideleave', function(e) {
         window.jQuery(e.target).trigger('hidden');
      });
       window.jQuery(document).on('slideenter', function(e) {
         window.jQuery(e.target).trigger('shown');
      });
    }
  })();
</script>

</body>
</html>
